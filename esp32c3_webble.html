<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ESP32-C3 WebBLE Controller</title>
<style>
  :root { --pad: 12px; --radius: 12px; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: var(--pad); max-width: 920px; }
  header { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
  h1 { font-size: 1.25rem; margin: 0; }
  #status { margin-left: auto; font-size: .9rem; opacity: .85; }
  .row { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
  .card { border: 1px solid #e8e8e8; border-radius: var(--radius); padding: var(--pad); margin-top: var(--pad); }
  button, input, select { padding: 10px 12px; border-radius: 10px; border: 1px solid #ddd; }
  button { cursor: pointer; box-shadow: 0 1px 2px rgba(0,0,0,.06); }
  label { font-weight: 600; }
  #log { white-space: pre-wrap; border: 1px solid #eee; border-radius: 10px; padding: 10px; height: 160px; overflow: auto; background: #fafafa; }
  #pitch { font-variant-numeric: tabular-nums; font-size: 1.25rem; font-weight: 700; }
  .pill { display: inline-block; padding: 2px 8px; border-radius: 999px; background: #f0f0f0; font-size: .8rem; }
  canvas { width: 100%; height: 260px; border: 1px solid #eee; border-radius: 10px; display: block; background: #fff; }
  .muted { opacity: .7; font-size: .9rem; }
  .spacer { flex: 1; }
</style>
<body>
<header>
  <h1>ESP32-C3 WebBLE Controller</h1>
  <span id="status" class="pill">Disconnected</span>
</header>

<div class="row" style="margin-top:8px">
  <button id="btnConnect">Connect</button>
  <button id="btnDisconnect">Disconnect</button>
  <button id="btnClear">Clear Log</button>
  <span class="muted">Device: <code id="devname">C3-PWM</code></span>
</div>

<div class="card">
  <div class="row">
    <div><label>Pitch:</label> <span id="pitch">–</span> °</div>
    <div class="muted">Print @ ESP: <span id="rate">60</span> Hz</div>
    <div class="spacer"></div>
    <button id="btnSaveCsv" title="Save current IMU buffer to CSV">Save CSV</button>
  </div>
  <canvas id="plot" width="900" height="260"></canvas>
</div>

<div class="card">
  <div class="row" style="margin-bottom:6px"><label>IMU Control</label>
    <button id="btnStartStream">Start Stream</button>
    <button id="btnStopStream">Stop Stream</button>
    <button id="btnCal3s">Calibrate (3s zero)</button>
  </div>
  <div class="muted">Calibration averages the current pitch for 3 seconds and sets it as zero on the ESP.</div>
</div>

<div class="card">
  <div class="row">
    <label>Freq (Hz)</label>
    <input id="freq" type="number" inputmode="numeric" value="100" style="width:110px" />
    <label>Duty (%)</label>
    <input id="duty" type="number" inputmode="numeric" value="50" style="width:90px" />
    <button id="btnStart">Start</button>
    <button id="btnStop">Stop</button>
  </div>
</div>

<div class="card">
  <div class="row" style="margin-bottom:6px"><label>Angle Trigger</label>
    <button id="btnTrigOn">Enable Trigger</button>
    <button id="btnTrigOff">Disable Trigger</button>
    <label>Threshold (°)</label>
    <input id="th" type="number" value="30" style="width:90px" />
  </div>
</div>

<div class="card">
  <div class="row">
    <label><input id="chkPause" type="checkbox"/> Pause plot</label>
    <label><input id="chkAutoscale" type="checkbox" checked/> Autoscale Y</label>
    <label>Fixed range (±°)</label>
    <input id="fixedRange" type="number" value="90" style="width:90px" />
    <label><input id="chkThresh" type="checkbox" checked/> Show threshold line</label>
  </div>
</div>

<!-- Folder picker and auto-naming status -->
<div class="card">
  <div class="row" style="margin-bottom:6px"><label>Save Location</label>
    <button id="btnChooseFolder">Choose Folder</button>
    <span class="muted">Folder: <code id="folderName">— not set —</code></span>
    <span class="spacer"></span>
    <span class="muted">Next file: <code id="nextFileName">Log1.csv</code></span>
  </div>
  <div class="muted">After choosing a folder, each Save will write <code>Log1.csv</code>, <code>Log2.csv</code>, … into that folder.</div>
</div>

<div class="card">
  <div class="row" style="margin-bottom:6px"><label>Console</label></div>
  <div id="log"></div>
</div>

<script>
  // ---- Settings (same as original) ----
  const DEVICE_NAME = "C3-PWM";
  const NUS_SERVICE = "6e400001-b5a3-f393-e0a9-e50e24dcca9e"; // UART service
  const NUS_TX      = "6e400003-b5a3-f393-e0a9-e50e24dcca9e"; // notify (ESP->phone)
  const NUS_RX      = "6e400002-b5a3-f393-e0a9-e50e24dcca9e"; // write  (phone->ESP)

  // ---- UI elements ----
  const devnameEl     = document.getElementById('devname');
  const statusEl      = document.getElementById('status');
  const pitchEl       = document.getElementById('pitch');
  const logEl         = document.getElementById('log');
  const freqEl        = document.getElementById('freq');
  const dutyEl        = document.getElementById('duty');
  const thEl          = document.getElementById('th');
  const plot          = document.getElementById('plot');
  const ctx           = plot.getContext('2d');
  const btnTrigOn     = document.getElementById('btnTrigOn');
  const btnTrigOff    = document.getElementById('btnTrigOff');
  const chkPause      = document.getElementById('chkPause');
  const chkAutoscale  = document.getElementById('chkAutoscale');
  const chkThresh     = document.getElementById('chkThresh');
  const fixedRangeEl  = document.getElementById('fixedRange');

  function log(s){ logEl.textContent += s + "\n"; logEl.scrollTop = logEl.scrollHeight; }
  function setStatus(s){ statusEl.textContent = s; }

  // ---- BLE state ----
  let device, server, service, txChar, rxChar;
  let connecting = false;

  document.getElementById('btnConnect').onclick = connect;
  document.getElementById('btnDisconnect').onclick = disconnect;
  document.getElementById('btnClear').onclick = () => { logEl.textContent = ""; };

  // PWM
  document.getElementById('btnStart').onclick = () => sendLine('PWM,'+freqEl.value+','+dutyEl.value);
  document.getElementById('btnStop').onclick  = () => sendLine('STOP');

  // IMU controls
  document.getElementById('btnStartStream').onclick = () => sendLine('STREAM,ON');
  document.getElementById('btnStopStream').onclick  = () => sendLine('STREAM,OFF');
  document.getElementById('btnCal3s').onclick       = () => sendLine('CAL,3000');

  btnTrigOn.onclick  = () => { triggerEnabled = true; lastEdgeState = null; log('Angle trigger enabled'); };
  btnTrigOff.onclick = () => { triggerEnabled = false; lastEdgeState = null; log('Angle trigger disabled'); };
  document.getElementById('btnSaveCsv').onclick = saveCsv;

  // Folder picker
  document.getElementById('btnChooseFolder').onclick = chooseFolder;
  const folderNameEl = document.getElementById('folderName');
  const nextFileNameEl = document.getElementById('nextFileName');

  // Folder save state
  let dirHandle = null;
  let nextLogIndex = Number(localStorage.getItem('csvLogIndex') || '1');
  function updateNextName(){ nextFileNameEl.textContent = `Log${nextLogIndex}.csv`; }
  updateNextName();

  async function chooseFolder(){
    if (!('showDirectoryPicker' in window)) {
      alert('This browser does not support folder saving. Use Chrome/Edge for full support.');
      return;
    }
    try {
      dirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
      folderNameEl.textContent = dirHandle.name || '(selected)';
      // Determine next Log index by scanning existing Log*.csv files
      const maxIdx = await findMaxLogIndexInDir(dirHandle);
      nextLogIndex = Math.max(maxIdx + 1, Number(localStorage.getItem('csvLogIndex') || '1'));
      updateNextName();
      log('Folder selected: ' + dirHandle.name);
    } catch (e) {
      if (e.name === 'AbortError') { log('Folder select canceled.'); return; }
      log('Folder select error: ' + e);
    }
  }

  async function findMaxLogIndexInDir(handle){
    let maxIdx = 0;
    try {
      for await (const [name, entry] of handle.entries()){
        if (entry.kind === 'file'){
          const m = /^Log(\d+)\.csv$/i.exec(name);
          if (m) {
            const n = parseInt(m[1], 10);
            if (!Number.isNaN(n) && n > maxIdx) maxIdx = n;
          }
        }
      }
    } catch (e) {
      const perm = await handle.requestPermission?.({ mode: 'readwrite' });
      if (perm === 'granted') return findMaxLogIndexInDir(handle);
    }
    return maxIdx;
  }

  // ---- IMU buffers & trigger ----
  const BUF_MAX = 1200;          // ~60s if drawing at 20 FPS
  const WINDOW_LEN = 300;        // show last 300 samples like PC GUI
  const pitchBuf = [];
  const timeBuf  = [];
  let sampleIndex = 0;

  let triggerEnabled = false;
  let lastEdgeState = null;  // null/true/false
  let lastActionTs = 0;
  const debounceMs = 200;
  const xOn  = [];
  const xOff = [];

  function pushSample(v){
    const t = Date.now()/1000;
    pitchBuf.push(v); timeBuf.push(t); sampleIndex++;
    if (pitchBuf.length > BUF_MAX){ pitchBuf.shift(); timeBuf.shift(); }
  }

  function applyTrigger(v){
    if (!triggerEnabled) return;
    const th = Math.abs(Number(thEl.value)||30);
    const on = Math.abs(v) >= th;
    const now = Date.now();
    if (lastEdgeState === null){
      lastEdgeState = on;
      if (on && now-lastActionTs>debounceMs){ sendLine('PWM,'+freqEl.value+','+dutyEl.value); xOn.push(sampleIndex); lastActionTs=now; }
      return;
    }
    if (on !== lastEdgeState && (now-lastActionTs>debounceMs)){
      if (on){ sendLine('PWM,'+freqEl.value+','+dutyEl.value); xOn.push(sampleIndex); }
      else    { sendLine('STOP'); xOff.push(sampleIndex); }
      lastEdgeState = on; lastActionTs = now;
    }
  }

  // ---- Notifications ----
  function onNotify(ev){
    const s = new TextDecoder().decode(ev.target.value).trim();
    if (!s) return;
    s.split(/\n+/).forEach(handleLine);
  }

  function handleLine(line){
    if (line.indexOf('PITCH,') === 0){
      const v = parseFloat(line.split(',')[1]);
      if (!isNaN(v)){
        if (!chkPause.checked){
          pitchEl.textContent = v.toFixed(2);
          pushSample(v); applyTrigger(v);
        }
      }
    } else {
      log(line);
    }
  }

  // ---- Plotting ----
  function draw(){
    const w = plot.width, h = plot.height; ctx.clearRect(0,0,w,h);
    // axes
    ctx.strokeStyle = '#e5e5e5'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(40, 10); ctx.lineTo(40, h-20); ctx.lineTo(w-10, h-20); ctx.stroke();

    // Axis labels
    ctx.fillStyle = '#000000'; ctx.font = '12px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText('Sample Index (last ' + WINDOW_LEN + ' samples)', w/2, h);
    ctx.save(); ctx.translate(10, h/2); ctx.rotate(-Math.PI / 2); ctx.fillText('Pitch (degrees)', 0, 0); ctx.restore();

    if (!pitchBuf.length){ requestAnimationFrame(draw); return; }

    // Windowed view
    const right = sampleIndex + 1;
    const left  = Math.max(0, right - WINDOW_LEN);
    const startCut = Math.max(0, pitchBuf.length - WINDOW_LEN);
    const ys = pitchBuf.slice(startCut);

    // Y limits
    let y0=-90, y1=90;
    if (chkAutoscale.checked){
      const mn = Math.min.apply(null, ys), mx = Math.max.apply(null, ys);
      const pad = Math.max(2, 0.1 * (mx - mn + 1e-6));
      y0 = mn - pad; y1 = mx + pad;
    } else {
      const rng = Math.abs(Number(fixedRangeEl.value)||90); y0 = -rng; y1 = +rng;
    }

    // Y tick labels
    ctx.textAlign = 'right'; ctx.font = '10px sans-serif';
    const centerVal = (y0 + y1) / 2;
    [y1, centerVal, y0].forEach(val => {
      const yp = mapY(val, y0, y1, h);
      ctx.fillText(val.toFixed(0), 38, yp + 4);
    });

    // zero line
    const yZero = mapY(0, y0, y1, h); ctx.strokeStyle = '#bbbbbb'; ctx.setLineDash([4,4]); ctx.beginPath(); ctx.moveTo(40, yZero); ctx.lineTo(w-10, yZero); ctx.stroke(); ctx.setLineDash([]);

    // threshold lines
    if (chkThresh.checked){
      const th = Math.abs(Number(thEl.value)||30);
      const yT  = mapY(th,  y0, y1, h); const yTN = mapY(-th, y0, y1, h);
      ctx.strokeStyle = '#000000'; ctx.setLineDash([2,4]);
      ctx.beginPath(); ctx.moveTo(40, yT);  ctx.lineTo(w-10, yT);  ctx.stroke();
      ctx.beginPath(); ctx.moveTo(40, yTN); ctx.lineTo(w-10, yTN); ctx.stroke();
      ctx.setLineDash([]);
    }

    // plot line
    ctx.strokeStyle = '#0b6bf2'; ctx.lineWidth = 2; ctx.beginPath();
    const N = WINDOW_LEN;
    for (let k=0; k<ys.length; k++){
      const xp = mapX(k, N, w);
      const yp = mapY(ys[k], y0, y1, h);
      if (k===0) ctx.moveTo(xp, yp); else ctx.lineTo(xp, yp);
    }
    ctx.stroke();

    // vertical ON/OFF marks within window
    ctx.setLineDash([6,4]); ctx.lineWidth = 1;
    ctx.strokeStyle = 'red';
    xOn.forEach(ix => { if (ix>=left && ix<right){ const xmap = mapX(ix-left, WINDOW_LEN, w); ctx.beginPath(); ctx.moveTo(xmap, 10); ctx.lineTo(xmap, h-20); ctx.stroke(); }});
    ctx.strokeStyle = 'green';
    xOff.forEach(ix => { if (ix>=left && ix<right){ const xmap2 = mapX(ix-left, WINDOW_LEN, w); ctx.beginPath(); ctx.moveTo(xmap2, 10); ctx.lineTo(xmap2, h-20); ctx.stroke(); }});
    ctx.setLineDash([]);

    requestAnimationFrame(draw);
  }

  function mapX(i, N, w){ const left=40, right=w-10; return left + (i/Math.max(1,N))*(right-left); }
  function mapY(v, ymin, ymax, h){ const top=10, bot=h-20; const t = (v - ymin)/(ymax - ymin + 1e-9); return bot - t*(bot-top); }

  requestAnimationFrame(function loop(){ draw(); requestAnimationFrame(loop); });

  // ---- send helper (prefer writeWithoutResponse on iOS) ----
  async function sendLine(s){
    if (!rxChar){ log('Not connected'); return; }
    const data = new TextEncoder().encode(s.endsWith('\n')?s:(s+'\n'));
    try{
      if ('writeValueWithoutResponse' in rxChar) await rxChar.writeValueWithoutResponse(data);
      else await rxChar.writeValue(data);
      log('> ' + s);
    }catch(e){ log('Write error: ' + e); }
  }

  // ---- CSV saving with flags + folder autosave (Log1, Log2, ...) ----
  async function saveCsv(){
    if (!pitchBuf.length){ log('No data to save'); return; }

    // Build CSV with flags (ON/OFF)
    const onSet  = new Set(xOn);
    const offSet = new Set(xOff);
    const startIdx = sampleIndex - pitchBuf.length + 1;
    const t0 = timeBuf[0];

    let csv = 'timestamp_s,t_rel_s,sample_index,pitch_deg,flag\n';
    for (let i=0; i<pitchBuf.length; i++){
      const t_abs = timeBuf[i];
      const t_rel = t_abs - t0;
      const idx   = startIdx + i;
      let flag = '';
      if (onSet.has(idx)) flag = '1';
      else if (offSet.has(idx)) flag = '0';

      csv += (
        t_abs.toFixed(6)+','+
        t_rel.toFixed(6)+','+
        idx+','+
        Number(pitchBuf[i]).toFixed(6)+','+
        flag+'\n'
      );
    }
    const blob = new Blob([csv], {type: 'text/csv'});

    // Save to chosen folder if available
    if (dirHandle){
      const p = await dirHandle.requestPermission?.({ mode: 'readwrite' }) || 'granted';
      if (p === 'granted'){
        const filename = `Log${nextLogIndex}.csv`;
        try{
          const fileHandle = await dirHandle.getFileHandle(filename, { create: true });
          const writable = await fileHandle.createWritable();
          await writable.write(blob);
          await writable.close();
          log(`Saved ${pitchBuf.length} samples with flags to ${dirHandle.name}/${filename}`);
          nextLogIndex += 1;
          localStorage.setItem('csvLogIndex', String(nextLogIndex));
          updateNextName();
          return;
        }catch(e){
          log('Folder save error: ' + e + ' — falling back to Save As / download.');
        }
      } else {
        log('Write permission denied for the chosen folder — falling back to Save As / download.');
      }
    }

    // Fallback: Save As… else download
    const defaultName = `Log${nextLogIndex}.csv`;
    if ('showSaveFilePicker' in window){
      try{
        const handle = await window.showSaveFilePicker({
          suggestedName: defaultName,
          types: [{ description: 'CSV file', accept: { 'text/csv': ['.csv'] } }]
        });
        const writable = await handle.createWritable();
        await writable.write(blob);
        await writable.close();
        log('Saved ' + (handle.name || defaultName));
        nextLogIndex += 1;
        localStorage.setItem('csvLogIndex', String(nextLogIndex));
        updateNextName();
        return;
      }catch(e){
        if (e.name === 'AbortError'){ log('Save canceled.'); return; }
        log('Save error: ' + e + ' — using download fallback.');
      }
    }
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = defaultName;
    document.body.appendChild(a); a.click(); document.body.removeChild(a);
    URL.revokeObjectURL(url);
    log('Saved ' + defaultName + ' (download fallback)');
    nextLogIndex += 1;
    localStorage.setItem('csvLogIndex', String(nextLogIndex));
    updateNextName();
  }

  // ---- iOS hint ----
  (function iosHint(){
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    if (isIOS && !('bluetooth' in navigator)){
      log('Tip: On iOS, open this page in Bluefy or WebBLE to enable Web Bluetooth.');
    }
  })();

  // BLE connect/disconnect (unchanged)
  async function connect(){
    if (!('bluetooth' in navigator)) { alert('This browser does not support Web Bluetooth. On iOS, open this page in Bluefy or WebBLE.'); return; }
    if (server?.connected){ log('Already connected'); return; }
    if (connecting) { return; }
    connecting = true;
    try{
      setStatus('Requesting…');
      device = await navigator.bluetooth.requestDevice({
        // EXACTLY as original: OR of service, name, namePrefix
        filters: [
          { services: [NUS_SERVICE] },
          { name: DEVICE_NAME },
          { namePrefix: 'C3-' }
        ],
        optionalServices: [NUS_SERVICE]
      });
      device.addEventListener('gattserverdisconnected', onDisconnected);
      devnameEl.textContent = device.name || DEVICE_NAME;

      setStatus('Connecting…');
      server  = await device.gatt.connect();
      service = await server.getPrimaryService(NUS_SERVICE);
      txChar  = await service.getCharacteristic(NUS_TX);
      rxChar  = await service.getCharacteristic(NUS_RX);

      await txChar.startNotifications();
      txChar.addEventListener('characteristicvaluechanged', onNotify);

      setStatus('Connected');
      log('Connected to ' + (device.name||'ESP32-C3'));
    }catch(e){
      setStatus('Disconnected');
      log('Connect error: ' + e);
    } finally {
      connecting = false;
    }
  }

  function onDisconnected(){
    setStatus('Disconnected');
    if (txChar) {
      try { txChar.stopNotifications(); } catch(e){}
      txChar.removeEventListener('characteristicvaluechanged', onNotify);
    }
    txChar = rxChar = service = server = null;
    log('Disconnected.');
  }

  async function disconnect(){
    try {
      if (txChar) {
        try { await txChar.stopNotifications(); } catch(e){}
        txChar.removeEventListener('characteristicvaluechanged', onNotify);
      }
      if (device?.gatt?.connected) device.gatt.disconnect();
    } catch(e) {
      log('Disconnect error: ' + e);
    } finally {
      txChar = rxChar = service = server = null;
      await new Promise(r => setTimeout(r, 700));
      setStatus('Disconnected');
    }
  }
</script>
</body>
</html>
