<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ESP32-C3 WebBLE – Multi-Device</title>
<style>
  :root {
    --pad: 10px;
    --radius: 12px;
    --muted: #6b7280;
    --line: #e5e7eb;
  }
  * { box-sizing: border-box; }
  body {
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    margin: 0;
    padding: 14px 16px;
    color: #111827;
    background: #fafafa;
  }
  header {
    display: flex; align-items: center; gap: 10px;
    margin-bottom: 8px; flex-wrap: wrap;
  }
  header h1 { font-size: 1.1rem; margin: 0; font-weight: 800; letter-spacing: .2px; }
  header .hint { color: var(--muted); font-size: .9rem; }

  /* Compact controls */
  button, input, select {
    padding: 6px 8px; border-radius: 10px; border: 1px solid #ddd; background: #fff; font: inherit;
  }
  button { cursor: pointer; box-shadow: 0 1px 2px rgba(0,0,0,.06); }
  .btn-outline { background: #fff; }
  .btn-primary { background: #0b6bf2; color: #fff; border-color: #0b6bf2; }
  .btn-danger { background: #ef4444; color:#fff; border-color:#ef4444; }

  .pill { display: inline-block; padding: 2px 8px; border-radius: 999px; background: #f3f4f6; font-size: .8rem; }
  .muted { color: var(--muted); font-size: .9rem; }
  .small { font-size: .85rem; }
  .row { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; }

  /* Card + layout */
  .device-card { border: 1px solid var(--line); border-radius: 14px; padding: 8px 8px 10px; margin: 8px 0 12px; background: #fff; }
  .dev-head { display: flex; align-items: center; gap: 8px; margin: 2px 4px 6px; }
  .dev-title { font-weight: 700; }
  .status { margin-left: auto; }

  /* Two-column main layout: left (plots), right (controls) */
  .grid-main { display: grid; grid-template-columns: 1.6fr 1fr; gap: 12px; }
  .col { border-left: 1px dashed #e5e7eb; padding-left: 10px; }
  .col:first-child { border-left: 0; padding-left: 0; }

  .panel { margin-bottom: 8px; }
  .panel .title { font-weight: 700; margin-bottom: 4px; font-size: .98rem; }

  .controls { display: flex; gap: 6px; flex-wrap: wrap; }
  .stack { display: grid; gap: 6px; }
  .field { display: grid; grid-template-columns: auto 1fr; gap: 6px; align-items: center; }

  canvas {
    width: 100%; height: 240px; background: #fff; border: 1px solid #eee; border-radius: 10px; display: block;
  }

  .console { margin-top: 8px; border: 1px solid #eee; border-radius: 10px; background: #fafafa; padding: 8px; height: 120px; overflow: auto; white-space: pre-wrap; }
  .sep { height: 1px; background: #f1f1f1; margin: 10px 0; }
  .top-right { margin-left: auto; display: flex; gap: 6px; }
  .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
  .tag { font-variant-numeric: tabular-nums; font-weight: 700; }
</style>
<body>
<header>
  <h1>ESP32-C3 WebBLE – Multi-Device</h1>
  <button id="btnAdd" class="btn-primary">Add Device</button>
  <span class="hint">Each click connects one ESP32-C3 (Chrome/Edge desktop recommended).</span>
</header>

<div id="devices"></div>

<script>
/* =================== Shared constants (same as before) =================== */
const NUS_SERVICE = "6e400001-b5a3-f393-e0a9-e50e24dcca9e";
const NUS_TX      = "6e400003-b5a3-f393-e0a9-e50e24dcca9e";
const NUS_RX      = "6e400002-b5a3-f393-e0a9-e50e24dcca9e";

/* ===== DPI-aware canvas helper (crisp lines, less rework) ===== */
function resizeCanvasDPR(canvas, ctx){
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const cssW = Math.round(rect.width);
  const cssH = Math.round(rect.height);
  const wantW = Math.max(1, Math.floor(cssW * dpr));
  const wantH = Math.max(1, Math.floor(cssH * dpr));
  if (canvas.width !== wantW || canvas.height !== wantH){
    canvas.width = wantW;
    canvas.height = wantH;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixel space
  }
}



/* =================== Log Buffer Throttling =================== */
// Place this section near the top, before DeviceCard class 
let _logBuffer = [];
let _logFlushTimer = null;
function flushLogBuffer() {
  if (_logBuffer.length === 0) return;
  for (const msg of _logBuffer) msg.el.textContent += msg.text + "\n";
  _logBuffer = [];
  _logFlushTimer = null;
}


/* =================== Global RAF scheduler =================== */
const _cards = [];
let _rafId = null;

let _lastDrawTs = 0;
const FRAME_INTERVAL = 33; // ~30 fps

function globalFrame(ts){
  if (ts - _lastDrawTs < FRAME_INTERVAL) {
    _rafId = requestAnimationFrame(globalFrame);
    return;
  }
  _lastDrawTs = ts;
  for (const c of _cards){
    resizeCanvasDPR(c.timePlot, c.timeCtx);
    resizeCanvasDPR(c.phPlot, c.phCtx);
    c.drawTime();
    if (c.portraitOn) c.drawPortrait();
  }
  _rafId = requestAnimationFrame(globalFrame);
}


/* =================== DeviceCard class =================== */
class DeviceCard {
  constructor(container) {
    this.root = document.createElement('div');
    this.root.className = 'device-card';
    this.root.innerHTML = this.template();
    container.appendChild(this.root);

    // Header
    this.titleEl   = this.root.querySelector('.dev-title');
    this.statusEl  = this.root.querySelector('.status');
    this.pitchEl   = this.root.querySelector('.pitchval');
    this.rateEl    = this.root.querySelector('.rateval');

    // Canvases
    this.timePlot  = this.root.querySelector('.plot-time');
    this.timeCtx   = this.timePlot.getContext('2d');
    this.phPlot    = this.root.querySelector('.plot-portrait');
    this.phCtx     = this.phPlot.getContext('2d');

    // initial DPI sizing
    resizeCanvasDPR(this.timePlot, this.timeCtx);
    resizeCanvasDPR(this.phPlot, this.phCtx);

    // Buttons
    this.btnConnect     = this.root.querySelector('.btnConnect');
    this.btnDisconnect  = this.root.querySelector('.btnDisconnect');
    this.btnClear       = this.root.querySelector('.btnClear');
    this.btnSave        = this.root.querySelector('.btnSave');

    this.btnStartStream = this.root.querySelector('.btnStartStream');
    this.btnStopStream  = this.root.querySelector('.btnStopStream');
    this.btnCal3s       = this.root.querySelector('.btnCal3s');

    this.btnStartPWM    = this.root.querySelector('.btnStartPWM');
    this.btnStopPWM     = this.root.querySelector('.btnStopPWM');

    this.btnTrigOn      = this.root.querySelector('.btnTrigOn');
    this.btnTrigOff     = this.root.querySelector('.btnTrigOff');

    this.btnStartPortrait = this.root.querySelector('.btnStartPortrait');
    this.btnStopPortrait  = this.root.querySelector('.btnStopPortrait');

    // Random FM selectors
    this.inMinFreq    = this.root.querySelector('.inMinFreq');
    this.inMaxFreq    = this.root.querySelector('.inMaxFreq');
    this.btnFMOn      = this.root.querySelector('.btnFMOn');
    this.btnFMOff     = this.root.querySelector('.btnFMOff');
    this.inFMInterval = this.root.querySelector('.inFMInterval');

    // Inputs
    this.inFreq      = this.root.querySelector('.inFreq');
    this.inDuty      = this.root.querySelector('.inDuty');
    this.selDir      = this.root.querySelector('.selDir');
    this.inStartTh   = this.root.querySelector('.inStartTh');
    this.inStopTh    = this.root.querySelector('.inStopTh');

    this.chkPause    = this.root.querySelector('.chkPause');
    this.chkAutoscale= this.root.querySelector('.chkAutoscale');
    this.inFixedRange= this.root.querySelector('.inFixedRange');
    this.chkThresh   = this.root.querySelector('.chkThresh');

    // Save UI
    this.btnChooseFolder = this.root.querySelector('.btnChooseFolder');
    this.folderNameEl    = this.root.querySelector('.folderName');
    this.baseNameEl      = this.root.querySelector('.baseName');
    this.counterEl       = this.root.querySelector('.counter');
    this.previewEl       = this.root.querySelector('.previewName');

    // Log
    this.logEl = this.root.querySelector('.console');

    // State
    this.device = this.server = this.service = this.txChar = this.rxChar = null;
    this.connecting = false;

    // IMU buffers
    this.BUF_MAX = 1800;
    this.WIN = 400;
    this.pitchBuf = [];
    this.timeBuf  = [];
    this.sampleIndex = 0;

    // Trigger state (hysteresis)
    this.triggerEnabled = false;
    this.lastEdgeState = null;
       this.lastActionTs = 0;
    this.debounceMs = 200;
    this.xOn = new Set();
    this.xOff= new Set();

    /* ----------- PHASE PORTRAIT STATE ----------- */
    this.portraitOn = false;
    this.velBuf = [];
    this.lastPitch = null;
    this.derivAlpha = 0.25;

    // Autoscaling state for phase portrait
    this.ppScale = { xMin: -90, xMax: 90, yMin: -20, yMax: 20 };
    this.ppAlpha = 0.2;
    this.ppWin   = 300;
    this.ppMinXSpan = 10;
    this.ppMinYSpan = 2;

    // Angle→Frequency Map (state)
    this.angleMapEnabled   = false;
    this.mapTimer          = null;
    this.mapPeriodMs       = 50;
    this.mapLastHz         = null;
    this.mapDeadbandHz     = 2;

    // Folder save
    this.dirHandle = null;

    // Base+counter persisted per device card
    this.baseNameEl.value = localStorage.getItem('csvBaseName') || 'Log';
    this.counterEl.value  = localStorage.getItem('csvCounter')  || '1';
    this.updatePreview();

    this.baseNameEl.addEventListener('input', ()=>{
      localStorage.setItem('csvBaseName', this.baseNameEl.value);
      this.updatePreview();
    });
    this.counterEl.addEventListener('input', ()=>{
      localStorage.setItem('csvCounter', String(parseInt(this.counterEl.value||'0',10)||0));
      this.updatePreview();
    });

    // Wire handlers
    this.btnConnect.onclick    = ()=> this.connect();
    this.btnDisconnect.onclick = ()=> this.disconnect();
    this.btnClear.onclick      = ()=> (this.logEl.textContent="");
    this.btnSave.onclick       = ()=> this.saveCsv();

    this.btnStartStream.onclick= ()=> this.sendLine('STREAM,ON');
    this.btnStopStream.onclick = ()=> this.sendLine('STREAM,OFF');
    this.btnCal3s.onclick      = ()=> this.sendLine('CAL,3000');

    this.btnStartPWM.onclick   = ()=> this.sendLine(`PWM,${this.inFreq.value},${this.inDuty.value}`);
    this.btnStopPWM.onclick    = ()=> { this.stopFM(); this.sendLine('STOP'); };

    this.btnTrigOn.onclick     = ()=>{ this.triggerEnabled=true; this.lastEdgeState=null; this.log('Angle trigger ENABLED'); };
    this.btnTrigOff.onclick    = ()=>{ this.triggerEnabled=false; this.lastEdgeState=null; this.log('Angle trigger DISABLED'); };

    this.btnStartPortrait.onclick = ()=>{ this.portraitOn = true; };
    this.btnStopPortrait.onclick  = ()=>{ this.portraitOn = false; this.clearPortrait(); this.drawPortraitAxes(); };

    this.btnChooseFolder.onclick = ()=> this.chooseFolder();

    // Random FM handlers/state
    this.fmEnabled = false;
    this.fmTimer = null;
    this.fmPeriodMs = 250;
    this.btnFMOn.onclick  = ()=> this.startFM();
    this.btnFMOff.onclick = ()=> this.stopFM();

    if (this.inFMInterval) {
      this.inFMInterval.addEventListener('input', ()=>{
        this.setFMPeriodFromInput();
        if (this.fmEnabled) this.restartFMTimer();
      });
    }

    // Angle→Frequency Map (wire up handlers)
    this.inAngMin     = this.root.querySelector('.inAngMin');
    this.inAngMax     = this.root.querySelector('.inAngMax');
    this.inMapFmin    = this.root.querySelector('.inMapFmin');
    this.inMapFmax    = this.root.querySelector('.inMapFmax');
    this.inMapPeriod  = this.root.querySelector('.inMapPeriod');
    this.inMapDeadbn  = this.root.querySelector('.inMapDeadbn');
    this.btnMapOn     = this.root.querySelector('.btnMapOn');
    this.btnMapOff    = this.root.querySelector('.btnMapOff');

    this.chkMapGuide  = this.root.querySelector('.chkMapGuide');

    if (this.btnMapOn)  this.btnMapOn.onclick  = ()=> this.startAngleMap();
    if (this.btnMapOff) this.btnMapOff.onclick = ()=> this.stopAngleMap();
    if (this.inMapPeriod){
      this.inMapPeriod.addEventListener('input', ()=>{
        const v = Math.max(20, Math.min(1000, parseInt(this.inMapPeriod.value||'50',10) || 50));
        this.mapPeriodMs = v;
        this.inMapPeriod.value = String(v);
        if (this.angleMapEnabled) this.restartAngleMapTimer();
      });
    }
    if (this.inMapDeadbn){
      this.inMapDeadbn.addEventListener('input', ()=>{
        let v = parseFloat(this.inMapDeadbn.value||'2');
        if (!isFinite(v)) v = 2;
        v = Math.max(0, Math.min(50, v));
        this.mapDeadbandHz = v;
        this.inMapDeadbn.value = String(v);
      });
    }

    // initial axes
    this.drawPortraitAxes();
  }

  template(){
    /* Layout: Left stack (Time -> IMU Control -> Phase Portrait -> Plot options), Right column (controls) */
    return `
      <div class="dev-head">
        <div class="dev-title">System_V3_Actuator2</div>
        <span class="muted">Pitch: <span class="tag pitchval">–</span> °</span>
        <span class="muted">• Print @ ESP: <span class="tag rateval">60</span> Hz</span>
        <div class="top-right">
          <button class="btnSave">Save CSV</button>
          <button class="btnClear">Clear Log</button>
          <button class="btnDisconnect btn-outline">Disconnect</button>
        </div>
        <span class="pill status">Disconnected</span>
      </div>

      <div class="grid-main">
        <!-- LEFT COLUMN (stacked plots) -->
        <div class="col">
          <!-- Time plot -->
          <canvas class="plot-time" width="900" height="240"></canvas>
          <!-- IMU Control -->
          <div class="panel" style="margin-top:8px">
            <div class="title">IMU Control</div>
            <div class="controls">
              <button class="btnStartStream">Start Stream</button>
              <button class="btnStopStream">Stop Stream</button>
              <button class="btnCal3s">Calibrate (3s zero)</button>
              <button class="btnConnect btn-primary">Connect</button>
            </div>
          </div>

          <!-- Phase portrait -->
          <canvas class="plot-portrait" width="900" height="240"></canvas>
          <!-- Plot options -->
          <div class="panel" style="margin-top:8px">
            <div class="title">Plot options</div>
            <div class="stack">
              <label class="row"><input type="checkbox" class="chkPause"/> Pause plot</label>
              <label class="row"><input type="checkbox" class="chkAutoscale" checked/> Autoscale Y</label>
              <div class="field"><span>Fixed range (±°)</span><input type="number" class="inFixedRange" value="90"></div>
              <label class="row"><input type="checkbox" class="chkThresh" checked/> Show thresholds</label>
              <div class="controls">
                <button class="btnStartPortrait">Start Portrait</button>
                <button class="btnStopPortrait">Stop Portrait</button>
              </div>
            </div>
          </div>
        </div>

        <!-- RIGHT COLUMN (unchanged controls) -->
        <div class="col">
          <div class="panel">
            <div class="title">PWM</div>
            <div class="grid2">
              <div class="field"><span>Freq (Hz)</span><input type="number" class="inFreq" value="100"></div>
              <div class="field"><span>Duty (%)</span><input type="number" class="inDuty" value="50"></div>
            </div>
            <div class="controls" style="margin-top:6px">
              <button class="btnStartPWM">Start</button>
              <button class="btnStopPWM">Stop</button>
            </div>
          </div>

          <div class="panel">
            <div class="title">Random Frequency Modulation</div>
            <div class="grid2">
              <div class="field"><span>Min Freq (Hz)</span><input type="number" class="inMinFreq" value="50"></div>
              <div class="field"><span>Max Freq (Hz)</span><input type="number" class="inMaxFreq" value="150"></div>
            </div>
            <div class="grid2" style="margin-top:6px">
              <div class="field"><span>Interval (ms)</span><input type="number" class="inFMInterval" value="250"></div>
              <div></div>
            </div>
            <div class="controls" style="margin-top:6px">
              <button class="btnFMOn">FM Start</button>
              <button class="btnFMOff btn-outline">FM Stop</button>
            </div>
          </div>

          <div class="panel">
            <div class="title">Angle → Frequency Map</div>
            <div class="grid2">
              <div class="field"><span>Angle min (°)</span><input type="number" class="inAngMin" value="30"></div>
              <div class="field"><span>Angle max (°)</span><input type="number" class="inAngMax" value="50"></div>
            </div>
            <div class="grid2" style="margin-top:6px">
              <div class="field"><span>Freq min (Hz)</span><input type="number" class="inMapFmin" value="100"></div>
              <div class="field"><span>Freq max (Hz)</span><input type="number" class="inMapFmax" value="200"></div>
            </div>
            <div class="grid2" style="margin-top:6px">
              <div class="field"><span>Update (ms)</span><input type="number" class="inMapPeriod" value="50"></div>
              <div class="field"><span>Deadband (Hz)</span><input type="number" class="inMapDeadbn" value="2"></div>
            </div>
            <div class="grid2" style="margin-top:6px">
              <label class="row"><input type="checkbox" class="chkMapGuide" checked> Show window on plot</label>
              <div></div>
            </div>
            <div class="controls" style="margin-top:6px">
              <button class="btnMapOn">Map Start</button>
              <button class="btnMapOff btn-outline">Map Stop</button>
            </div>
            <div class="muted small">Maps angle linearly: 30°→100 Hz, 50°→200 Hz (and vice versa). Stops PWM outside angle window.</div>
          </div>

          <div class="panel">
            <div class="title">Angle Trigger (Hysteresis)</div>
            <div class="stack">
              <div class="controls">
                <button class="btnTrigOn">Enable Trigger</button>
                <button class="btnTrigOff">Disable Trigger</button>
              </div>
              <div class="field">
                <span>Direction</span>
                <select class="selDir">
                  <option value="pos">Positive (↑)</option>
                  <option value="neg">Negative (↓)</option>
                </select>
              </div>
              <div class="grid2">
                <div class="field"><span>Start Th (°)</span><input type="number" class="inStartTh" value="30"></div>
                <div class="field"><span>Stop Th (°)</span><input type="number" class="inStopTh" value="20"></div>
              </div>
            </div>
          </div>

          <div class="panel">
            <div class="title">Save to folder (optional)</div>
            <div class="controls">
              <button class="btnChooseFolder">Choose Folder</button>
              <span class="muted">Folder: <span class="folderName">–</span></span>
            </div>
            <div class="grid2" style="margin-top:6px">
              <div class="field"><span>Base</span><input class="baseName" type="text" value="Log"></div>
              <div class="field"><span>#</span><input class="counter" type="number" value="1"></div>
            </div>
            <div class="muted small" style="margin-top:4px">Preview: <code class="previewName">Log_1.csv</code></div>
          </div>
        </div>
      </div>

      <div class="console"></div>
    `;
  }

  /* ---------- helpers ---------- */
  /* ---------- helpers ---------- */
  // Replace the log method with throttled version
  log(s){
    _logBuffer.push({ el: this.logEl, text: s });
    if (!_logFlushTimer) {
      _logFlushTimer = setTimeout(flushLogBuffer, 100); // flush every 100ms
    }
    this.logEl.scrollTop = this.logEl.scrollHeight;
  }
  setStatus(s){ this.statusEl.textContent = s; }

  updatePreview(){
    const base = (this.baseNameEl.value || 'Log').replace(/[\/\\:\*\?"<>\|]/g,'').trim() || 'Log';
    const num  = Math.max(0, parseInt(this.counterEl.value,10) || 0);
    this.previewEl.textContent = `${base}_${num}.csv`;
  }
  currentFilename(){
    const base = (this.baseNameEl.value || 'Log').replace(/[\/\\:\*\?"<>\|]/g,'').trim() || 'Log';
    const num  = Math.max(0, parseInt(this.counterEl.value,10) || 0);
    return `${base}_${num}.csv`;
  }
  bumpCounter(){
    const next = (parseInt(this.counterEl.value||'0',10)||0)+1;
    this.counterEl.value = String(next);
    localStorage.setItem('csvCounter', this.counterEl.value);
    this.updatePreview();
  }

  async verifyWritePermission(dirHandle){
    const opts = { mode: 'readwrite' };
    if (dirHandle.queryPermission && await dirHandle.queryPermission(opts) === 'granted') return true;
    if (dirHandle.requestPermission && await dirHandle.requestPermission(opts) === 'granted') return true;
    return false;
  }

  async chooseFolder(){
    if (!('showDirectoryPicker' in window)){
      alert("Folder saving requires Chrome/Edge desktop.");
      return;
    }
    try{
      this.dirHandle = await window.showDirectoryPicker({ mode:'readwrite' });
      this.folderNameEl.textContent = this.dirHandle.name || 'selected';
      this.log('Folder selected: ' + this.dirHandle.name);
    }catch(e){
      if (e && e.name === 'AbortError'){ this.log('Folder select canceled.'); return; }
      this.log('Folder select error: ' + e);
    }
  }

  /* ---------- BLE ---------- */
  async connect(){
    if (!('bluetooth' in navigator)){ alert('This browser does not support Web Bluetooth.'); return; }
    if (this.server?.connected){ this.log('Already connected'); return; }
    if (this.connecting) return;
    this.connecting = true;
    try{
      this.setStatus('Requesting…');
      const device = await navigator.bluetooth.requestDevice({
        filters: [
          { services: [NUS_SERVICE] },
          { namePrefix: 'C3-' },
        ],
        optionalServices: [NUS_SERVICE]
      });
      this.device = device;
      this.device.addEventListener('gattserverdisconnected', ()=> this.onDisconnected());
      this.titleEl.textContent = device.name || this.titleEl.textContent;

      this.setStatus('Connecting…');
      this.server  = await device.gatt.connect();
      this.service = await this.server.getPrimaryService(NUS_SERVICE);
      this.txChar  = await this.service.getCharacteristic(NUS_TX);
      this.rxChar  = await this.service.getCharacteristic(NUS_RX);

      await this.txChar.startNotifications();
      this.txChar.addEventListener('characteristicvaluechanged', (ev)=> this.onNotify(ev));

      this.setStatus('Connected');
      this.log('Connected to ' + (device.name || 'ESP32-C3'));
    }catch(e){
      this.setStatus('Disconnected');
      this.log('Connect error: ' + e);
    }finally{
      this.connecting = false;
    }
  }

  async disconnect(){
    try{
      this.stopFM();
      if (this.txChar){
        try{ await this.txChar.stopNotifications(); }catch(e){}
        this.txChar.removeEventListener('characteristicvaluechanged', this.onNotify);
      }
      if (this.device?.gatt?.connected) this.device.gatt.disconnect();
    }catch(e){
      this.log('Disconnect error: ' + e);
    }finally{
      this.txChar=this.rxChar=this.service=this.server=null;
      this.setStatus('Disconnected');
      this.log('Disconnected.');
    }
  }
  onDisconnected(){ this.setStatus('Disconnected'); this.txChar=this.rxChar=this.service=this.server=null; this.log('Disconnected.'); }

  async sendLine(s){
    if (!this.rxChar){ this.log('Not connected'); return; }
    const data = new TextEncoder().encode(s.endsWith('\n')?s:(s+'\n'));
    try{
      if ('writeValueWithoutResponse' in this.rxChar) await this.rxChar.writeValueWithoutResponse(data);
      else await this.rxChar.writeValue(data);
      this.log('> ' + s);
    }catch(e){ this.log('Write error: ' + e); }
  }

  /* ---------- Notify handler ---------- */
  onNotify(ev){
    const s = new TextDecoder().decode(ev.target.value).trim();
    if (!s) return;
    s.split(/\n+/).forEach(line=>{
      if (line.indexOf('PITCH,')===0){
        const v = parseFloat(line.split(',')[1]);
        if (!isNaN(v) && !this.chkPause.checked){
          this.pitchEl.textContent = v.toFixed(2);
          this.pushSample(v);
          this.applyTrigger(v);
        }
      } else {
        this.log(line);
      }
    });
  }

  /* ---------- Buffers & trigger ---------- */
  pushSample(v){
    const t = performance.now()/1000;
    this.pitchBuf.push(v);
    this.timeBuf.push(t);
    this.sampleIndex++;

    if (this.lastPitch == null) this.lastPitch = v;
    const rawVel = v - this.lastPitch;
    const lastVel = this.velBuf.length ? this.velBuf[this.velBuf.length-1] : rawVel;
    const vel = lastVel + this.derivAlpha * (rawVel - lastVel);
    this.velBuf.push(vel);
    this.lastPitch = v;

    if (this.pitchBuf.length > this.BUF_MAX){
      this.pitchBuf.shift(); this.timeBuf.shift(); this.velBuf.shift();
    }
  }

  applyTrigger(v){
    if (!this.triggerEnabled) return;
    const dir = this.selDir.value;
    const startMag = Math.abs(Number(this.inStartTh.value)||30);
    const stopMag  = Math.abs(Number(this.inStopTh.value)||20);

    let onNow, offNow;
    if (dir === 'pos'){ onNow = v >=  startMag; offNow = v <=  stopMag; }
    else              { onNow = v <= -startMag; offNow = v >= -stopMag; }

    const now = performance.now();
    if (this.lastEdgeState === null){ this.lastEdgeState = onNow; return; }

    if (!this.lastEdgeState && onNow && (now - this.lastActionTs > this.debounceMs)){
      this.sendLine(`PWM,${this.inFreq.value},${this.inDuty.value}`);
      this.xOn.add(this.sampleIndex);
      this.lastEdgeState = true; this.lastActionTs = now;
    } else if (this.lastEdgeState && offNow && (now - this.lastActionTs > this.debounceMs)){
      this.sendLine('STOP');
      this.xOff.add(this.sampleIndex);
      this.lastEdgeState = false; this.lastActionTs = now;
    }
  }

  /* ---------- Drawing: time plot (decimated) ---------- */
  drawTime(){
    const ctx = this.timeCtx, w=this.timePlot.width/(window.devicePixelRatio||1), h=this.timePlot.height/(window.devicePixelRatio||1);
    ctx.clearRect(0,0,w,h);

    // axes
    ctx.strokeStyle = '#e5e5e5'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(40, 10); ctx.lineTo(40, h-20); ctx.lineTo(w-10, h-20); ctx.stroke();
    if (!this.pitchBuf.length) return;

    const right = this.sampleIndex + 1;
    const left  = Math.max(0, right - this.WIN);
    const startCut = Math.max(0, this.pitchBuf.length - this.WIN);
    const ys = this.pitchBuf.slice(startCut);

    let y0=-90, y1=90;
    if (this.chkAutoscale.checked){
      let mn = Infinity, mx = -Infinity;
      for (let i=0;i<ys.length;i++){ const v=ys[i]; if (v<mn) mn=v; if (v>mx) mx=v; }
      const pad = Math.max(2, 0.1 * (mx - mn + 1e-6)); y0 = mn - pad; y1 = mx + pad;
    } else {
      const rng = Math.abs(Number(this.inFixedRange.value)||90); y0 = -rng; y1 = rng;
    }

    const mapY=(v)=>{ const top=10, bot=h-20; const t=(v - y0)/(y1 - y0 + 1e-9); return bot - t*(bot-top); };
    const mapX=(i)=>{ const L=40, R=w-10; return L + (i/Math.max(1,this.WIN))*(R-L); };

    // zero line
    const yZero = mapY(0);
    ctx.setLineDash([4,4]); ctx.strokeStyle = '#cbd5e1';
    ctx.beginPath(); ctx.moveTo(40, yZero); ctx.lineTo(w-10, yZero); ctx.stroke(); ctx.setLineDash([]);

    // === Hysteresis thresholds as translucent band (if enabled) ===
    if (this.chkThresh.checked){
      const dir=this.selDir.value, startMag=Math.abs(Number(this.inStartTh.value)||30), stopMag=Math.abs(Number(this.inStopTh.value)||20);
      // positive: band between stop and start (both +); negative: band between -start and -stop (both -)
      const low  = (dir==='pos') ? stopMag : -startMag;
      const high = (dir==='pos') ? startMag : -stopMag;
      let yA = mapY(low), yB = mapY(high);
      if (yB < yA) [yA, yB] = [yB, yA];
      const L = 40, R = w - 10;

      ctx.save();
      ctx.fillStyle = 'rgba(17,24,39,0.10)';   // subtle charcoal band
      ctx.fillRect(L, yA, R - L, Math.max(0, yB - yA));
      ctx.strokeStyle = 'rgba(17,24,39,0.55)';
      ctx.lineWidth = 1;
      // edges
      ctx.beginPath(); ctx.moveTo(L, yA); ctx.lineTo(R, yA); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(L, yB); ctx.lineTo(R, yB); ctx.stroke();
      // labels
      ctx.fillStyle = '#6b7280';
      ctx.font = '10px system-ui';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'bottom';
      ctx.fillText(dir==='pos' ? 'Start (↑)' : 'Start (↓)', R - 2, yA - 2);
      ctx.textBaseline = 'top';
      ctx.fillText('Stop', R - 2, yB + 2);
      ctx.restore();
    }

    // === Angle window: translucent band (if enabled) ===
    if (this.inAngMin && this.inAngMax && this.chkMapGuide?.checked){
      const amin = parseFloat(this.inAngMin.value || '30');
      const amax = parseFloat(this.inAngMax.value || '50');
      let yA = mapY(amin), yB = mapY(amax);
      if (yB < yA) [yA, yB] = [yB, yA];
      const L = 40, R = w - 10;

      ctx.save();
      ctx.fillStyle = 'rgba(124,58,237,0.12)'; // purple band
      ctx.fillRect(L, yA, R - L, Math.max(0, yB - yA));

      ctx.strokeStyle = 'rgba(124,58,237,0.65)';
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(L, yA); ctx.lineTo(R, yA); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(L, yB); ctx.lineTo(R, yB); ctx.stroke();

      ctx.fillStyle = '#6b7280';
      ctx.font = '10px system-ui';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'bottom';
      ctx.fillText('Angle max', R - 2, yA - 2);
      ctx.textBaseline = 'top';
      ctx.fillText('Angle min', R - 2, yB + 2);
      ctx.restore();
    }

    // data series (per-pixel decimation)
    const L = 40, R = w - 10;
    const widthPx = Math.max(1, Math.floor(R - L));
    const total = ys.length;
    const step = Math.max(1, Math.floor(total / widthPx));

    ctx.strokeStyle = '#1f6feb';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let k = 0; k < total; k += step){
      const xp = mapX(k);
      const yp = mapY(ys[k]);
      if (k === 0) ctx.moveTo(xp, yp); else ctx.lineTo(xp, yp);
    }
    if (total > 0){
      const xp = mapX(total-1);
      const yp = mapY(ys[total-1]);
      ctx.lineTo(xp, yp);
    }
    ctx.stroke();

    // ON/OFF markers
    ctx.setLineDash([6,4]); ctx.lineWidth=1;
    ctx.strokeStyle='red';
    const leftIdx = left;
    this.xOn.forEach(ix=>{
      if (ix>=left && ix<right){
        const x = mapX(ix-leftIdx);
        ctx.beginPath(); ctx.moveTo(x,10); ctx.lineTo(x,h-20); ctx.stroke();
      }
    });
    ctx.strokeStyle='green';
    this.xOff.forEach(ix=>{
      if (ix>=left && ix<right){
        const x = mapX(ix-leftIdx);
        ctx.beginPath(); ctx.moveTo(x,10); ctx.lineTo(x,h-20); ctx.stroke();
      }
    });
    ctx.setLineDash([]);

    // axis labels
    ctx.save();
    ctx.fillStyle = '#6b7280';
    ctx.font = '11px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'alphabetic';
    ctx.fillText('Samples', (w-10 + 40)/2, h - 4);
    ctx.translate(14, (h-20 + 10)/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText('Angle (deg)', 0, 0);
    ctx.restore();
  }

  drawTimeLoop(){ /* global RAF */ }

  /* ---------- Phase portrait ---------- */
  clearPortrait(){ this.phCtx.clearRect(0,0,this.phPlot.width/(window.devicePixelRatio||1),this.phPlot.height/(window.devicePixelRatio||1)); }

  drawPortraitAxes(zx = null, zy = null){
    const dpr = window.devicePixelRatio || 1;
    const ctx=this.phCtx, w=this.phPlot.width/dpr, h=this.phPlot.height/dpr;
    ctx.clearRect(0,0,w,h);
    ctx.strokeStyle='#e5e5e5'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(40, 10); ctx.lineTo(40, h-20); ctx.lineTo(w-10, h-20); ctx.stroke();

    if (zx !== null || zy !== null){
      ctx.setLineDash([4,4]); ctx.strokeStyle='#cbd5e1';
      if (zy !== null){ ctx.beginPath(); ctx.moveTo(40, zy); ctx.lineTo(w-10, zy); ctx.stroke(); }
      if (zx !== null){ ctx.beginPath(); ctx.moveTo(zx, 10); ctx.lineTo(zx, h-20); ctx.stroke(); }
      ctx.setLineDash([]);
    }

    // axis labels
    ctx.save();
    ctx.fillStyle = '#6b7280';
    ctx.font = '11px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'alphabetic';
    ctx.fillText('Pitch (deg)', (w-10 + 40)/2, h - 4);
    ctx.translate(18, (h-20 + 10)/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText('Velocity (deg/step)', 0, 0);
    ctx.restore();
  }

  drawPortrait(){
    const dpr = window.devicePixelRatio || 1;
    const ctx=this.phCtx, w=this.phPlot.width/dpr, h=this.phPlot.height/dpr;
    if (!this.portraitOn){ return; }
    this.drawPortraitAxes();
    if (this.pitchBuf.length < 3) return;

    const N = Math.min(this.ppWin, this.pitchBuf.length);
    const start = this.pitchBuf.length - N;
    const sliceP = this.pitchBuf.slice(start);
    const sliceV = this.velBuf.slice(start).map(v => v ?? 0);

    let pMin = Math.min(...sliceP), pMax = Math.max(...sliceP);
    const pPad = Math.max(2, 0.1 * (pMax - pMin + 1e-6));
    pMin -= pPad; pMax += pPad;
    if ((pMax - pMin) < this.ppMinXSpan){ const mid = 0.5*(pMin + pMax); pMin = mid - this.ppMinXSpan/2; pMax = mid + this.ppMinXSpan/2; }

    let vMin = Math.min(...sliceV), vMax = Math.max(...sliceV);
    const vPad = Math.max(0.5, 0.15 * (vMax - vMin + 1e-6));
    vMin -= vPad; vMax += vPad;
    if (!isFinite(vMin) || !isFinite(vMax) || vMin === vMax){ vMin = this.ppScale.yMin; vMax = this.ppScale.yMax; }
    if ((vMax - vMin) < this.ppMinYSpan){ const mid = 0.5*(vMin + vMax); vMin = mid - this.ppMinYSpan/2; vMax = mid + this.ppMinYSpan/2; }

    const a = this.ppAlpha, lerp = (o,n,t)=> o + t*(n - o);
    this.ppScale.xMin = lerp(this.ppScale.xMin, pMin, a);
    this.ppScale.xMax = lerp(this.ppScale.xMax, pMax, a);
    this.ppScale.yMin = lerp(this.ppScale.yMin, vMin, a);
    this.ppScale.yMax = lerp(this.ppScale.yMax, vMax, a);

    const { xMin, xMax, yMin, yMax } = this.ppScale;
    const mapX=(v)=>{ const L=40,R=w-10; const t=(v-xMin)/((xMax-xMin)+1e-9); return L + t*(R-L); };
    const mapY=(d)=>{ const T=10,B=h-20; const t=(d-yMin)/((yMax-yMin)+1e-9); return B - t*(B-T); };

    this.drawPortraitAxes(mapX(0), mapY(0));

    ctx.strokeStyle = '#ef4444';
    ctx.lineWidth = 1.75; ctx.beginPath();
    for (let i=start; i<this.pitchBuf.length; i++){
      const px = mapX(this.pitchBuf[i]);
      const py = mapY(this.velBuf[i] || 0);
      if (i===start) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.stroke();
  }

  /* ---------- CSV ---------- */
  async saveCsv(){
    if (!this.pitchBuf.length){ this.log('Nothing to save.'); return; }
    const onSet = this.xOn;
    const startIdx = this.sampleIndex - this.pitchBuf.length + 1;
    const t0 = this.timeBuf[0];

    let csv='timestamp_s,t_rel_s,sample_index,pitch_deg,vel_ema,flag\n';
    for (let i=0;i<this.pitchBuf.length;i++){
      const t_abs=this.timeBuf[i];
      const t_rel=t_abs - t0;
      const idx  =startIdx + i;
      const pitch=Number(this.pitchBuf[i]).toFixed(6);
      const vel  =(this.velBuf[i] ?? 0);
      const flag = onSet.has(idx) ? '1' : '0';
      csv += `${t_abs.toFixed(6)},${t_rel.toFixed(6)},${idx},${pitch},${vel.toFixed(6)},${flag}\n`;
    }

    const blob = new Blob([csv], {type:'text/csv'});
    const filename = this.currentFilename();

    if (this.dirHandle){
      try{
        const ok = await this.verifyWritePermission(this.dirHandle);
        if (ok){
          const f = await this.dirHandle.getFileHandle(filename, {create:true});
          const w = await f.createWritable();
          await w.write(blob);
          await w.close();
          this.log(`Saved ${this.pitchBuf.length} samples to ${this.dirHandle.name}/${filename}`);
          this.bumpCounter();
          return;
        }
      }catch(e){ this.log('Folder save error: '+e+' — falling back.'); }
    }

    if ('showSaveFilePicker' in window){
      try{
        const handle = await window.showSaveFilePicker({
          suggestedName: filename,
          types: [{ description: 'CSV file', accept: {'text/csv':['.csv']} }]
        });
        const w = await handle.createWritable();
        await w.write(blob);
        await w.close();
        this.log('Saved ' + (handle.name || filename));
        this.bumpCounter();
        return;
      }catch(e){
        if (e && e.name==='AbortError'){ this.log('Save canceled.'); return; }
        this.log('Save As error: '+e+' — using download fallback.');
      }
    }

    const url=URL.createObjectURL(blob);
    const a=document.createElement('a');
    a.href=url; a.download=filename;
    document.body.appendChild(a); a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    this.log('Saved '+filename+' (download fallback)');
    this.bumpCounter();
  }

  /* === Random FM methods === */
  setFMPeriodFromInput(){
    let v = parseInt(this.inFMInterval?.value ?? '250', 10);
    if (!isFinite(v)) v = 250;
    v = Math.max(50, Math.min(10000, v));
    this.fmPeriodMs = v;
    if (this.inFMInterval) this.inFMInterval.value = String(v);
  }

  fmTick(){
    if (!this.fmEnabled || !this.rxChar) return;
    let lo = Math.max(1, parseInt(this.inMinFreq.value||'0',10) || 1);
    let hi = Math.max(1, parseInt(this.inMaxFreq.value||'0',10) || 1);
    if (hi < lo) [lo, hi] = [hi, lo];
    const duty = this.inDuty.value || 50;
    const span = hi - lo;
    const rnd = (span > 0) ? (lo + Math.floor(Math.random()*(span+1))) : lo;
    this.sendLine(`PWM,${rnd},${duty}`);
  }

  restartFMTimer(){
    if (!this.fmEnabled) return;
    if (this.fmTimer){ clearInterval(this.fmTimer); this.fmTimer = null; }
    this.fmTimer = setInterval(()=> this.fmTick(), this.fmPeriodMs);
  }

  startFM(){
    if (this.fmEnabled) return;
    let minF = Math.max(1, parseInt(this.inMinFreq.value||'0',10) || 1);
    let maxF = Math.max(1, parseInt(this.inMaxFreq.value||'0',10) || 1);
    if (maxF < minF) [minF, maxF] = [maxF, minF];
    this.inMinFreq.value = String(minF);
    this.inMaxFreq.value = String(maxF);

    this.setFMPeriodFromInput();

    this.fmEnabled = true;
    this.log(`Random FM ON (${minF}–${maxF} Hz, ~${this.fmPeriodMs} ms step)`);
    this.fmTimer = setInterval(()=> this.fmTick(), this.fmPeriodMs);
  }

  stopFM(){
    if (!this.fmEnabled && !this.fmTimer) {
      if (this.rxChar) this.sendLine('STOP');
      this.log('Random FM OFF');
      return;
    }
    this.fmEnabled = false;
    if (this.fmTimer){ clearInterval(this.fmTimer); this.fmTimer = null; }
    if (this.rxChar) this.sendLine('STOP');
    this.log('Random FM OFF (PWM STOP)');
  }

  /* === Angle→Frequency Map === */
  startAngleMap(){
    if (this.angleMapEnabled) return;

    let amin = parseFloat(this.inAngMin?.value ?? '30');
    let amax = parseFloat(this.inAngMax?.value ?? '50');
    if (!isFinite(amin)) amin = 30;
    if (!isFinite(amax)) amax = 50;
    if (amax < amin) [amin, amax] = [amax, amin];
    this.inAngMin.value = String(amin);
    this.inAngMax.value = String(amax);

    let fmin = Math.max(1, parseFloat(this.inMapFmin?.value ?? '100') || 100);
    let fmax = Math.max(1, parseFloat(this.inMapFmax?.value ?? '200') || 200);
    if (fmax < fmin) [fmin, fmax] = [fmax, fmin];
    this.inMapFmin.value = String(fmin);
    this.inMapFmax.value = String(fmax);

    let per = parseInt(this.inMapPeriod?.value ?? '50', 10);
    if (!isFinite(per)) per = 50;
    this.mapPeriodMs = Math.max(20, Math.min(1000, per));
    this.inMapPeriod.value = String(this.mapPeriodMs);

    let db = parseFloat(this.inMapDeadbn?.value ?? '2');
    if (!isFinite(db)) db = 2;
    this.mapDeadbandHz = Math.max(0, Math.min(50, db));
    this.inMapDeadbn.value = String(this.mapDeadbandHz);

    this.stopFM();

    this.angleMapEnabled = true;
    this.mapLastHz = null;
    this.log(`Angle→Freq Map ON (${amin}–${amax}° → ${fmin}–${fmax} Hz, ${this.mapPeriodMs} ms, deadband ${this.mapDeadbandHz} Hz)`);
    this.mapTimer = setInterval(()=> this.angleMapTick(), this.mapPeriodMs);
  }

  stopAngleMap(){
    if (!this.angleMapEnabled && !this.mapTimer){
      if (this.rxChar) this.sendLine('STOP');
      this.log('Angle→Freq Map OFF');
      return;
    }
    this.angleMapEnabled = false;
    if (this.mapTimer){ clearInterval(this.mapTimer); this.mapTimer = null; }
    if (this.rxChar) this.sendLine('STOP');
    this.mapLastHz = null;
    this.log('Angle→Freq Map OFF (PWM STOP)');
  }

  restartAngleMapTimer(){
    if (!this.angleMapEnabled) return;
    if (this.mapTimer){ clearInterval(this.mapTimer); this.mapTimer = null; }
    this.mapTimer = setInterval(()=> this.angleMapTick(), this.mapPeriodMs);
  }

  angleMapTick(){
    if (!this.angleMapEnabled || !this.rxChar) return;
    if (!this.pitchBuf.length) return;

    const angle = this.pitchBuf[this.pitchBuf.length - 1];
    let amin = parseFloat(this.inAngMin.value || '30');
    let amax = parseFloat(this.inAngMax.value || '50');
    if (amax < amin) [amin, amax] = [amax, amin];

    let fmin = Math.max(1, parseFloat(this.inMapFmin.value || '100'));
    let fmax = Math.max(1, parseFloat(this.inMapFmax.value || '200'));
    if (fmax < fmin) [fmin, fmax] = [fmax, fmin];

    if (angle < amin || angle > amax){
      if (this.mapLastHz !== null){
        this.sendLine('STOP');
        this.mapLastHz = null;
      }
      return;
    }

    const t = (angle - amin) / Math.max(1e-9, (amax - amin));
    const freq = fmin + t * (fmax - fmin);
    const freqRounded = Math.round(freq);
    const last = this.mapLastHz ?? -Infinity;

    if (Math.abs(freqRounded - last) >= this.mapDeadbandHz){
      const duty = this.inDuty.value || 50;
      this.sendLine(`PWM,${freqRounded},${duty}`);
      this.mapLastHz = freqRounded;
    }
  }
}

/* =================== Page controller =================== */
const devicesEl = document.getElementById('devices');
document.getElementById('btnAdd').onclick = ()=>{
  const card = new DeviceCard(devicesEl);
  _cards.push(card);
  if (_cards.length === 1){
    requestAnimationFrame(globalFrame);
  }
  card.connect();
};

window.addEventListener('resize', ()=>{
  if (_rafId == null) _rafId = requestAnimationFrame(globalFrame);
});
</script>
</body>
</html>
