<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ESP32-C3 WebBLE – Multi-Device</title>
<style>
  :root { --pad: 12px; --radius: 12px; --muted: #6b7280; --line: #e5e7eb; }
  * { box-sizing: border-box; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 16px 18px; color: #111827; background: #fafafa; }
  header { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; flex-wrap: wrap; }
  header h1 { font-size: 1.15rem; margin: 0; font-weight: 800; letter-spacing: .2px; }
  header .hint { color: var(--muted); font-size: .9rem; }
  button, input, select { padding: 8px 10px; border-radius: 10px; border: 1px solid #ddd; background: #fff; font: inherit; }
  button { cursor: pointer; box-shadow: 0 1px 2px rgba(0,0,0,.06); }
  .pill { display: inline-block; padding: 2px 8px; border-radius: 999px; background: #f3f4f6; font-size: .8rem; }
  .muted { color: var(--muted); font-size: .9rem; }
  .row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
  .device-card { border: 1px solid var(--line); border-radius: 14px; padding: 10px 10px 12px; margin: 10px 0 16px; background: #fff; }
  .dev-head { display: flex; align-items: center; gap: 10px; margin: 2px 4px 8px; }
  .dev-title { font-weight: 700; }
  .status { margin-left: auto; }
  .grid3 { display: grid; grid-template-columns: 1.4fr 1.1fr 1fr; gap: 12px; }
  .col { border-left: 1px dashed #e5e7eb; padding-left: 12px; }
  .col:first-child { border-left: 0; padding-left: 0; }
  .panel { margin-bottom: 10px; }
  .panel .title { font-weight: 700; margin-bottom: 6px; }
  canvas { width: 100%; height: 240px; background: #fff; border: 1px solid #eee; border-radius: 10px; display: block; }
  .controls { display: flex; gap: 8px; flex-wrap: wrap; }
  .stack { display: grid; gap: 8px; }
  .field { display: grid; grid-template-columns: auto 1fr; gap: 8px; align-items: center; }
  .console { margin-top: 10px; border: 1px solid #eee; border-radius: 10px; background: #fafafa; padding: 10px; height: 120px; overflow: auto; white-space: pre-wrap; }
  .sep { height: 1px; background: #f1f1f1; margin: 12px 0; }
  .small { font-size: .85rem; }
  .btn-outline { background: #fff; }
  .btn-primary { background: #0b6bf2; color: #fff; border-color: #0b6bf2; }
  .btn-danger { background: #ef4444; color:#fff; border-color:#ef4444; }
  .top-right { margin-left: auto; display: flex; gap: 8px; }
  .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
  .tag { font-variant-numeric: tabular-nums; font-weight: 700; }
</style>
<body>
<header>
  <h1>ESP32-C3 WebBLE – Multi-Device</h1>
  <button id="btnAdd" class="btn-primary">Add Device</button>
  <span class="hint">Each click connects one ESP32-C3 (Chrome/Edge desktop recommended).</span>
</header>

<div id="devices"></div>

<script>
/* =================== Shared constants (same as before) =================== */
const NUS_SERVICE = "6e400001-b5a3-f393-e0a9-e50e24dcca9e";
const NUS_TX      = "6e400003-b5a3-f393-e0a9-e50e24dcca9e";
const NUS_RX      = "6e400002-b5a3-f393-e0a9-e50e24dcca9e";

/* =================== DeviceCard class =================== */
class DeviceCard {
  constructor(container) {
    this.root = document.createElement('div');
    this.root.className = 'device-card';
    this.root.innerHTML = this.template();
    container.appendChild(this.root);

    // Header
    this.titleEl   = this.root.querySelector('.dev-title');
    this.statusEl  = this.root.querySelector('.status');
    this.pitchEl   = this.root.querySelector('.pitchval');
    this.rateEl    = this.root.querySelector('.rateval');

    // Canvases
    this.timePlot  = this.root.querySelector('.plot-time');
    this.timeCtx   = this.timePlot.getContext('2d');
    this.phPlot    = this.root.querySelector('.plot-portrait');
    this.phCtx     = this.phPlot.getContext('2d');

    // Buttons
    this.btnConnect     = this.root.querySelector('.btnConnect');
    this.btnDisconnect  = this.root.querySelector('.btnDisconnect');
    this.btnClear       = this.root.querySelector('.btnClear');
    this.btnSave        = this.root.querySelector('.btnSave');

    this.btnStartStream = this.root.querySelector('.btnStartStream');
    this.btnStopStream  = this.root.querySelector('.btnStopStream');
    this.btnCal3s       = this.root.querySelector('.btnCal3s');

    this.btnStartPWM    = this.root.querySelector('.btnStartPWM');
    this.btnStopPWM     = this.root.querySelector('.btnStopPWM');

    this.btnTrigOn      = this.root.querySelector('.btnTrigOn');
    this.btnTrigOff     = this.root.querySelector('.btnTrigOff');

    this.btnStartPortrait = this.root.querySelector('.btnStartPortrait');
    this.btnStopPortrait  = this.root.querySelector('.btnStopPortrait');

    // === Random FM selectors ===
    this.inMinFreq    = this.root.querySelector('.inMinFreq');
    this.inMaxFreq    = this.root.querySelector('.inMaxFreq');
    this.btnFMOn      = this.root.querySelector('.btnFMOn');
    this.btnFMOff     = this.root.querySelector('.btnFMOff');
    this.inFMInterval = this.root.querySelector('.inFMInterval'); // === ADDED

    // Inputs
    this.inFreq      = this.root.querySelector('.inFreq');
    this.inDuty      = this.root.querySelector('.inDuty');
    this.selDir      = this.root.querySelector('.selDir');
    this.inStartTh   = this.root.querySelector('.inStartTh');
    this.inStopTh    = this.root.querySelector('.inStopTh');

    this.chkPause    = this.root.querySelector('.chkPause');
    this.chkAutoscale= this.root.querySelector('.chkAutoscale');
    this.inFixedRange= this.root.querySelector('.inFixedRange');
    this.chkThresh   = this.root.querySelector('.chkThresh');

    // Save UI
    this.btnChooseFolder = this.root.querySelector('.btnChooseFolder');
    this.folderNameEl    = this.root.querySelector('.folderName');
    this.baseNameEl      = this.root.querySelector('.baseName');
    this.counterEl       = this.root.querySelector('.counter');
    this.previewEl       = this.root.querySelector('.previewName');

    // Log
    this.logEl = this.root.querySelector('.console');

    // State
    this.device = this.server = this.service = this.txChar = this.rxChar = null;
    this.connecting = false;

    // IMU buffers
    this.BUF_MAX = 1800;
    this.WIN = 400;
    this.pitchBuf = [];
    this.timeBuf  = [];
    this.sampleIndex = 0;

    // Trigger state (hysteresis)
    this.triggerEnabled = false;
    this.lastEdgeState = null;
    this.lastActionTs = 0;
    this.debounceMs = 200;
    this.xOn = new Set();
    this.xOff= new Set();

    /* ----------- PHASE PORTRAIT STATE ----------- */
    this.portraitOn = false;
    this.velBuf = [];
    this.lastPitch = null;
    this.derivAlpha = 0.25;

    // Autoscaling state for phase portrait
    this.ppScale = { xMin: -90, xMax: 90, yMin: -20, yMax: 20 };
    this.ppAlpha = 0.2;     // smoothing factor for range updates (EMA)
    this.ppWin   = 300;     // samples considered for fitting
    this.ppMinXSpan = 10;   // deg
    this.ppMinYSpan = 2;    // deg/step

    // Folder save
    this.dirHandle = null;

    // Base+counter persisted per device card
    this.baseNameEl.value = localStorage.getItem('csvBaseName') || 'Log';
    this.counterEl.value  = localStorage.getItem('csvCounter')  || '1';
    this.updatePreview();

    this.baseNameEl.addEventListener('input', ()=>{
      localStorage.setItem('csvBaseName', this.baseNameEl.value);
      this.updatePreview();
    });
    this.counterEl.addEventListener('input', ()=>{
      localStorage.setItem('csvCounter', String(parseInt(this.counterEl.value||'0',10)||0));
      this.updatePreview();
    });

    // Wire handlers
    this.btnConnect.onclick    = ()=> this.connect();
    this.btnDisconnect.onclick = ()=> this.disconnect();
    this.btnClear.onclick      = ()=> (this.logEl.textContent="");
    this.btnSave.onclick       = ()=> this.saveCsv();

    this.btnStartStream.onclick= ()=> this.sendLine('STREAM,ON');
    this.btnStopStream.onclick = ()=> this.sendLine('STREAM,OFF');
    this.btnCal3s.onclick      = ()=> this.sendLine('CAL,3000');

    this.btnStartPWM.onclick   = ()=> this.sendLine(`PWM,${this.inFreq.value},${this.inDuty.value}`);
    this.btnStopPWM.onclick    = ()=> { this.stopFM(); this.sendLine('STOP'); }; // ensure FM stops with STOP

    this.btnTrigOn.onclick     = ()=>{ this.triggerEnabled=true; this.lastEdgeState=null; this.log('Angle trigger ENABLED'); };
    this.btnTrigOff.onclick    = ()=>{ this.triggerEnabled=false; this.lastEdgeState=null; this.log('Angle trigger DISABLED'); };

    this.btnStartPortrait.onclick = ()=>{ this.portraitOn = true; };
    this.btnStopPortrait.onclick  = ()=>{ this.portraitOn = false; this.clearPortrait(); this.drawPortraitAxes(); };

    this.btnChooseFolder.onclick = ()=> this.chooseFolder();

    // === Random FM handlers/state ===
    this.fmEnabled = false;
    this.fmTimer = null;
    this.fmPeriodMs = 250; // default
    this.btnFMOn.onclick  = ()=> this.startFM();
    this.btnFMOff.onclick = ()=> this.stopFM();

    // live interval edits restart the timer
    if (this.inFMInterval) {
      this.inFMInterval.addEventListener('input', ()=>{
        this.setFMPeriodFromInput();
        if (this.fmEnabled) this.restartFMTimer();
      });
    }

    // Start render loops
    this.drawTimeLoop();
    this.drawPortraitAxes();
  }

  template(){
    return `
      <div class="dev-head">
        <div class="dev-title">System_V3_Actuator2</div>
        <span class="muted">Pitch: <span class="tag pitchval">–</span> °</span>
        <span class="muted">• Print @ ESP: <span class="tag rateval">60</span> Hz</span>
        <div class="top-right">
          <button class="btnSave">Save CSV</button>
          <button class="btnClear">Clear Log</button>
          <button class="btnDisconnect btn-outline">Disconnect</button>
        </div>
        <span class="pill status">Disconnected</span>
      </div>

      <div class="grid3">
        <!-- Left column: time-series + IMU controls -->
        <div class="col">
          <canvas class="plot-time" width="900" height="240"></canvas>
          <div class="panel">
            <div class="title">IMU Control</div>
            <div class="controls">
              <button class="btnStartStream">Start Stream</button>
              <button class="btnStopStream">Stop Stream</button>
              <button class="btnCal3s">Calibrate (3s zero)</button>
              <button class="btnConnect btn-primary">Connect</button>
            </div>
          </div>
        </div>

        <!-- Middle column: portrait + plot options -->
        <div class="col">
          <canvas class="plot-portrait" width="900" height="240"></canvas>
          <div class="panel">
            <div class="title">Plot options</div>
            <div class="stack">
              <label class="row"><input type="checkbox" class="chkPause"/> Pause plot</label>
              <label class="row"><input type="checkbox" class="chkAutoscale" checked/> Autoscale Y</label>
              <div class="field"><span>Fixed range (±°)</span><input type="number" class="inFixedRange" value="90"/></div>
              <label class="row"><input type="checkbox" class="chkThresh" checked/> Show thresholds</label>
              <div class="controls">
                <button class="btnStartPortrait">Start Portrait</button>
                <button class="btnStopPortrait">Stop Portrait</button>
              </div>
            </div>
          </div>
        </div>

        <!-- Right column: PWM + Trigger + Save -->
        <div class="col">
          <div class="panel">
            <div class="title">PWM</div>
            <div class="grid2">
              <div class="field"><span>Freq (Hz)</span><input type="number" class="inFreq" value="100"/></div>
              <div class="field"><span>Duty (%)</span><input type="number" class="inDuty" value="50"/></div>
            </div>
            <div class="controls" style="margin-top:6px">
              <button class="btnStartPWM">Start</button>
              <button class="btnStopPWM">Stop</button>
            </div>

            <!-- Random FM controls -->
            <div class="sep"></div>
            <div class="title">Random Frequency Modulation</div>
            <div class="grid2">
              <div class="field"><span>Min Freq (Hz)</span><input type="number" class="inMinFreq" value="50"></div>
              <div class="field"><span>Max Freq (Hz)</span><input type="number" class="inMaxFreq" value="150"></div>
            </div>
            <div class="grid2" style="margin-top:6px">
              <div class="field"><span>Interval (ms)</span><input type="number" class="inFMInterval" value="250"></div>
              <div></div>
            </div>
            <div class="controls" style="margin-top:6px">
              <button class="btnFMOn">FM Start</button>
              <button class="btnFMOff btn-outline">FM Stop</button>
            </div>
            <!-- END Random FM controls -->
          </div>

          <div class="panel">
            <div class="title">Angle Trigger (Hysteresis)</div>
            <div class="stack">
              <div class="controls">
                <button class="btnTrigOn">Enable Trigger</button>
                <button class="btnTrigOff">Disable Trigger</button>
              </div>
              <div class="field">
                <span>Direction</span>
                <select class="selDir">
                  <option value="pos">Positive (↑)</option>
                  <option value="neg">Negative (↓)</option>
                </select>
              </div>
              <div class="grid2">
                <div class="field"><span>Start Th (°)</span><input type="number" class="inStartTh" value="30"/></div>
                <div class="field"><span>Stop Th (°)</span><input type="number" class="inStopTh" value="20"/></div>
              </div>
            </div>
          </div>

          <div class="panel">
            <div class="title">Save to folder (optional)</div>
            <div class="controls">
              <button class="btnChooseFolder">Choose Folder</button>
              <span class="muted">Folder: <span class="folderName">–</span></span>
            </div>
            <div class="grid2" style="margin-top:6px">
              <div class="field"><span>Base</span><input class="baseName" type="text" value="Log"></div>
              <div class="field"><span>#</span><input class="counter" type="number" value="1"></div>
            </div>
            <div class="muted small" style="margin-top:4px">Preview: <code class="previewName">Log_1.csv</code></div>
          </div>
        </div>
      </div>

      <div class="console"></div>
    `;
  }

  /* ---------- helpers ---------- */
  log(s){ this.logEl.textContent += s + "\n"; this.logEl.scrollTop = this.logEl.scrollHeight; }
  setStatus(s){ this.statusEl.textContent = s; }

  updatePreview(){
    const base = (this.baseNameEl.value || 'Log').replace(/[\/\\:\*\?"<>\|]/g,'').trim() || 'Log';
    const num  = Math.max(0, parseInt(this.counterEl.value,10) || 0);
    this.previewEl.textContent = `${base}_${num}.csv`;
  }
  currentFilename(){
    const base = (this.baseNameEl.value || 'Log').replace(/[\/\\:\*\?"<>\|]/g,'').trim() || 'Log';
    const num  = Math.max(0, parseInt(this.counterEl.value,10) || 0);
    return `${base}_${num}.csv`;
  }
  bumpCounter(){
    const next = (parseInt(this.counterEl.value||'0',10)||0)+1;
    this.counterEl.value = String(next);
    localStorage.setItem('csvCounter', this.counterEl.value);
    this.updatePreview();
  }

  async verifyWritePermission(dirHandle){
    const opts = { mode: 'readwrite' };
    if (dirHandle.queryPermission && await dirHandle.queryPermission(opts) === 'granted') return true;
    if (dirHandle.requestPermission && await dirHandle.requestPermission(opts) === 'granted') return true;
    return false;
  }

  async chooseFolder(){
    if (!('showDirectoryPicker' in window)){
      alert("Folder saving requires Chrome/Edge desktop.");
      return;
    }
    try{
      this.dirHandle = await window.showDirectoryPicker({ mode:'readwrite' });
      this.folderNameEl.textContent = this.dirHandle.name || 'selected';
      this.log('Folder selected: ' + this.dirHandle.name);
    }catch(e){
      if (e && e.name === 'AbortError'){ this.log('Folder select canceled.'); return; }
      this.log('Folder select error: ' + e);
    }
  }

  /* ---------- BLE ---------- */
  async connect(){
    if (!('bluetooth' in navigator)){ alert('This browser does not support Web Bluetooth.'); return; }
    if (this.server?.connected){ this.log('Already connected'); return; }
    if (this.connecting) return;
    this.connecting = true;
    try{
      this.setStatus('Requesting…');
      const device = await navigator.bluetooth.requestDevice({
        filters: [
          { services: [NUS_SERVICE] },
          { namePrefix: 'C3-' },
        ],
        optionalServices: [NUS_SERVICE]
      });
      this.device = device;
      this.device.addEventListener('gattserverdisconnected', ()=> this.onDisconnected());
      this.titleEl.textContent = device.name || this.titleEl.textContent;

      this.setStatus('Connecting…');
      this.server  = await device.gatt.connect();
      this.service = await this.server.getPrimaryService(NUS_SERVICE);
      this.txChar  = await this.service.getCharacteristic(NUS_TX);
      this.rxChar  = await this.service.getCharacteristic(NUS_RX);

      await this.txChar.startNotifications();
      this.txChar.addEventListener('characteristicvaluechanged', (ev)=> this.onNotify(ev));

      this.setStatus('Connected');
      this.log('Connected to ' + (device.name || 'ESP32-C3'));
    }catch(e){
      this.setStatus('Disconnected');
      this.log('Connect error: ' + e);
    }finally{
      this.connecting = false;
    }
  }

  async disconnect(){
    try{
      this.stopFM(); // ensure FM stops on disconnect
      if (this.txChar){
        try{ await this.txChar.stopNotifications(); }catch(e){}
        this.txChar.removeEventListener('characteristicvaluechanged', this.onNotify);
      }
      if (this.device?.gatt?.connected) this.device.gatt.disconnect();
    }catch(e){
      this.log('Disconnect error: ' + e);
    }finally{
      this.txChar=this.rxChar=this.service=this.server=null;
      this.setStatus('Disconnected');
      this.log('Disconnected.');
    }
  }
  onDisconnected(){ this.setStatus('Disconnected'); this.txChar=this.rxChar=this.service=this.server=null; this.log('Disconnected.'); }

  async sendLine(s){
    if (!this.rxChar){ this.log('Not connected'); return; }
    const data = new TextEncoder().encode(s.endsWith('\n')?s:(s+'\n'));
    try{
      if ('writeValueWithoutResponse' in this.rxChar) await this.rxChar.writeValueWithoutResponse(data);
      else await this.rxChar.writeValue(data);
      this.log('> ' + s);
    }catch(e){ this.log('Write error: ' + e); }
  }

  /* ---------- Notify handler ---------- */
  onNotify(ev){
    const s = new TextDecoder().decode(ev.target.value).trim();
    if (!s) return;
    s.split(/\n+/).forEach(line=>{
      if (line.indexOf('PITCH,')===0){
        const v = parseFloat(line.split(',')[1]);
        if (!isNaN(v) && !this.chkPause.checked){
          this.pitchEl.textContent = v.toFixed(2);
          this.pushSample(v);
          this.applyTrigger(v);
        }
      } else {
        this.log(line);
      }
    });
  }

  /* ---------- Buffers & trigger ---------- */
  pushSample(v){
    const t = performance.now()/1000;
    this.pitchBuf.push(v);
    this.timeBuf.push(t);
    this.sampleIndex++;

    if (this.lastPitch == null) this.lastPitch = v;
    const rawVel = v - this.lastPitch;
    const lastVel = this.velBuf.length ? this.velBuf[this.velBuf.length-1] : rawVel;
    const vel = lastVel + this.derivAlpha * (rawVel - lastVel);
    this.velBuf.push(vel);
    this.lastPitch = v;

    if (this.pitchBuf.length > this.BUF_MAX){
      this.pitchBuf.shift(); this.timeBuf.shift(); this.velBuf.shift();
    }
  }

  applyTrigger(v){
    if (!this.triggerEnabled) return;
    const dir = this.selDir.value;
    const startMag = Math.abs(Number(this.inStartTh.value)||30);
    const stopMag  = Math.abs(Number(this.inStopTh.value)||20);

    let onNow, offNow;
    if (dir === 'pos'){ onNow = v >=  startMag; offNow = v <=  stopMag; }
    else              { onNow = v <= -startMag; offNow = v >= -stopMag; }

    const now = performance.now();
    if (this.lastEdgeState === null){ this.lastEdgeState = onNow; return; }

    if (!this.lastEdgeState && onNow && (now - this.lastActionTs > this.debounceMs)){
      this.sendLine(`PWM,${this.inFreq.value},${this.inDuty.value}`);
      this.xOn.add(this.sampleIndex);
      this.lastEdgeState = true; this.lastActionTs = now;
    } else if (this.lastEdgeState && offNow && (now - this.lastActionTs > this.debounceMs)){
      this.sendLine('STOP');
      this.xOff.add(this.sampleIndex);
      this.lastEdgeState = false; this.lastActionTs = now;
    }
  }

  /* ---------- Drawing: time plot ---------- */
  drawTime(){
    const ctx = this.timeCtx, w=this.timePlot.width, h=this.timePlot.height;
    ctx.clearRect(0,0,w,h);

    ctx.strokeStyle = '#e5e5e5'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(40, 10); ctx.lineTo(40, h-20); ctx.lineTo(w-10, h-20); ctx.stroke();
    if (!this.pitchBuf.length) return;

    const right = this.sampleIndex + 1;
    const left  = Math.max(0, right - this.WIN);
    const startCut = Math.max(0, this.pitchBuf.length - this.WIN);
    const ys = this.pitchBuf.slice(startCut);

    let y0=-90, y1=90;
    if (this.chkAutoscale.checked){
      const mn = Math.min(...ys), mx = Math.max(...ys);
      const pad = Math.max(2, 0.1 * (mx - mn + 1e-6)); y0 = mn - pad; y1 = mx + pad;
    } else {
      const rng = Math.abs(Number(this.inFixedRange.value)||90); y0 = -rng; y1 = rng;
    }

    const mapY=(v)=>{ const top=10, bot=h-20; const t=(v - y0)/(y1 - y0 + 1e-9); return bot - t*(bot-top); };
    const mapX=(i)=>{ const L=40, R=w-10; return L + (i/Math.max(1,this.WIN))*(R-L); };

    const yZero = mapY(0);
    ctx.setLineDash([4,4]); ctx.strokeStyle = '#cbd5e1';
    ctx.beginPath(); ctx.moveTo(40, yZero); ctx.lineTo(w-10, yZero); ctx.stroke(); ctx.setLineDash([]);

    if (this.chkThresh.checked){
      const dir=this.selDir.value, startMag=Math.abs(Number(this.inStartTh.value)||30), stopMag=Math.abs(Number(this.inStopTh.value)||20);
      let yStart, yStop;
      if (dir==='pos'){ yStart = mapY(+startMag); yStop = mapY(+stopMag); }
      else            { yStart = mapY(-startMag); yStop = mapY(-stopMag); }
      ctx.setLineDash([2,4]); ctx.strokeStyle='#111827';
      ctx.beginPath(); ctx.moveTo(40,yStart); ctx.lineTo(w-10,yStart); ctx.stroke();
      ctx.setLineDash([6,3]); ctx.beginPath(); ctx.moveTo(40,yStop); ctx.lineTo(w-10,yStop); ctx.stroke();
      ctx.setLineDash([]);
    }

    ctx.strokeStyle = '#1f6feb'; ctx.lineWidth = 2; ctx.beginPath();
    for (let k=0; k<ys.length; k++){
      const xp = mapX(k), yp=mapY(ys[k]);
      if (k===0) ctx.moveTo(xp, yp); else ctx.lineTo(xp, yp);
    }
    ctx.stroke();

    ctx.setLineDash([6,4]); ctx.lineWidth=1;
    ctx.strokeStyle='red';
    const leftIdx = left;
    this.xOn.forEach(ix=>{
      if (ix>=left && ix<right){
        const x = mapX(ix-leftIdx);
        ctx.beginPath(); ctx.moveTo(x,10); ctx.lineTo(x,h-20); ctx.stroke();
      }
    });
    ctx.strokeStyle='green';
    this.xOff.forEach(ix=>{
      if (ix>=left && ix<right){
        const x = mapX(ix-leftIdx);
        ctx.beginPath(); ctx.moveTo(x,10); ctx.lineTo(x,h-20); ctx.stroke();
      }
    });
    ctx.setLineDash([]);
  }
  drawTimeLoop(){
    this.drawTime();
    requestAnimationFrame(()=> this.drawTimeLoop());
  }

  /* ---------- Drawing: portrait (AUTOSCALED) ---------- */
  clearPortrait(){ this.phCtx.clearRect(0,0,this.phPlot.width,this.phPlot.height); }

  // draw axes; zx, zy are pixel coordinates for zero lines (optional)
  drawPortraitAxes(zx = null, zy = null){
    const ctx=this.phCtx, w=this.phPlot.width, h=this.phPlot.height;
    ctx.clearRect(0,0,w,h);
    ctx.strokeStyle='#e5e5e5'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(40, 10); ctx.lineTo(40, h-20); ctx.lineTo(w-10, h-20); ctx.stroke();

    if (zx !== null || zy !== null){
      ctx.setLineDash([4,4]); ctx.strokeStyle='#cbd5e1';
      if (zy !== null){ ctx.beginPath(); ctx.moveTo(40, zy); ctx.lineTo(w-10, zy); ctx.stroke(); }
      if (zx !== null){ ctx.beginPath(); ctx.moveTo(zx, 10); ctx.lineTo(zx, h-20); ctx.stroke(); }
      ctx.setLineDash([]);
    }
  }

  drawPortrait(){
    const ctx=this.phCtx, w=this.phPlot.width, h=this.phPlot.height;
    if (!this.portraitOn){ return; }
    if (this.pitchBuf.length < 3){ this.drawPortraitAxes(); return; }

    // recent window
    const N = Math.min(this.ppWin, this.pitchBuf.length);
    const start = this.pitchBuf.length - N;
    const sliceP = this.pitchBuf.slice(start);
    const sliceV = this.velBuf.slice(start).map(v => v ?? 0);

    // target X (pitch) range
    let pMin = Math.min(...sliceP), pMax = Math.max(...sliceP);
    const pPad = Math.max(2, 0.1 * (pMax - pMin + 1e-6));
    pMin -= pPad; pMax += pPad;
    if ((pMax - pMin) < this.ppMinXSpan){
      const mid = 0.5*(pMin + pMax);
      pMin = mid - this.ppMinXSpan/2; pMax = mid + this.ppMinXSpan/2;
    }

    // target Y (velocity) range
    let vMin = Math.min(...sliceV), vMax = Math.max(...sliceV);
    const vPad = Math.max(0.5, 0.15 * (vMax - vMin + 1e-6));
    vMin -= vPad; vMax += vPad;
    if (!isFinite(vMin) || !isFinite(vMax) || vMin === vMax){
      vMin = this.ppScale.yMin; vMax = this.ppScale.yMax;
    }
    if ((vMax - vMin) < this.ppMinYSpan){
      const mid = 0.5*(vMin + vMax);
      vMin = mid - this.ppMinYSpan/2; vMax = mid + this.ppMinYSpan/2;
    }

    // smooth ranges
    const a = this.ppAlpha;
    const lerp = (o,n,t)=> o + t*(n - o);
    this.ppScale.xMin = lerp(this.ppScale.xMin, pMin, a);
    this.ppScale.xMax = lerp(this.ppScale.xMax, pMax, a);
    this.ppScale.yMin = lerp(this.ppScale.yMin, vMin, a);
    this.ppScale.yMax = lerp(this.ppScale.yMax, vMax, a);

    const { xMin, xMax, yMin, yMax } = this.ppScale;

    // mappers
    const mapX=(v)=>{ const L=40,R=w-10; const t=(v-xMin)/((xMax-xMin)+1e-9); return L + t*(R-L); };
    const mapY=(d)=>{ const T=10,B=h-20; const t=(d-yMin)/((yMax-yMin)+1e-9); return B - t*(B-T); };

    // axes at true zero positions
    this.drawPortraitAxes(mapX(0), mapY(0));

    // trace
    ctx.strokeStyle = '#ef4444';
    ctx.lineWidth = 1.75; ctx.beginPath();
    for (let i=start; i<this.pitchBuf.length; i++){
      const px = mapX(this.pitchBuf[i]);
      const py = mapY(this.velBuf[i] || 0);
      if (i===start) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.stroke();
  }

  /* ---------- CSV ---------- */
  async saveCsv(){
    if (!this.pitchBuf.length){ this.log('Nothing to save.'); return; }

    const onSet = this.xOn;
    const startIdx = this.sampleIndex - this.pitchBuf.length + 1;
    const t0 = this.timeBuf[0];

    let csv='timestamp_s,t_rel_s,sample_index,pitch_deg,vel_ema,flag\n';
    for (let i=0;i<this.pitchBuf.length;i++){
      const t_abs=this.timeBuf[i];
      const t_rel=t_abs - t0;
      const idx  =startIdx + i;
      const pitch=Number(this.pitchBuf[i]).toFixed(6);
      const vel  =(this.velBuf[i] ?? 0);
      const flag = onSet.has(idx) ? '1' : '0';

      csv += `${t_abs.toFixed(6)},${t_rel.toFixed(6)},${idx},${pitch},${vel.toFixed(6)},${flag}\n`;
    }

    const blob = new Blob([csv], {type:'text/csv'});
    const filename = this.currentFilename();

    if (this.dirHandle){
      try{
        const ok = await this.verifyWritePermission(this.dirHandle);
        if (ok){
          const f = await this.dirHandle.getFileHandle(filename, {create:true});
          const w = await f.createWritable();
          await w.write(blob);
          await w.close();
          this.log(`Saved ${this.pitchBuf.length} samples to ${this.dirHandle.name}/${filename}`);
          this.bumpCounter();
          return;
        }
      }catch(e){ this.log('Folder save error: '+e+' — falling back.'); }
    }

    if ('showSaveFilePicker' in window){
      try{
        const handle = await window.showSaveFilePicker({
          suggestedName: filename,
          types: [{ description: 'CSV file', accept: {'text/csv':['.csv']} }]
        });
        const w = await handle.createWritable();
        await w.write(blob);
        await w.close();
        this.log('Saved ' + (handle.name || filename));
        this.bumpCounter();
        return;
      }catch(e){
        if (e && e.name==='AbortError'){ this.log('Save canceled.'); return; }
        this.log('Save As error: '+e+' — using download fallback.');
      }
    }

    const url=URL.createObjectURL(blob);
    const a=document.createElement('a');
    a.href=url; a.download=filename;
    document.body.appendChild(a); a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    this.log('Saved '+filename+' (download fallback)');
    this.bumpCounter();
  }

  /* === Random FM methods (GUI-side only) === */
  setFMPeriodFromInput(){
    let v = parseInt(this.inFMInterval?.value ?? '250', 10);
    if (!isFinite(v)) v = 250;
    v = Math.max(50, Math.min(10000, v)); // 50–10000 ms clamp
    this.fmPeriodMs = v;
    if (this.inFMInterval) this.inFMInterval.value = String(v);
  }

  fmTick(){
    if (!this.fmEnabled || !this.rxChar) return;
    let lo = Math.max(1, parseInt(this.inMinFreq.value||'0',10) || 1);
    let hi = Math.max(1, parseInt(this.inMaxFreq.value||'0',10) || 1);
    if (hi < lo) [lo, hi] = [hi, lo];
    const duty = this.inDuty.value || 50;
    const span = hi - lo;
    const rnd = (span > 0) ? (lo + Math.floor(Math.random()*(span+1))) : lo;
    this.sendLine(`PWM,${rnd},${duty}`);
  }

  restartFMTimer(){
    if (!this.fmEnabled) return;
    if (this.fmTimer){ clearInterval(this.fmTimer); this.fmTimer = null; }
    this.fmTimer = setInterval(()=> this.fmTick(), this.fmPeriodMs);
  }

  startFM(){
    if (this.fmEnabled) return;
    let minF = Math.max(1, parseInt(this.inMinFreq.value||'0',10) || 1);
    let maxF = Math.max(1, parseInt(this.inMaxFreq.value||'0',10) || 1);
    if (maxF < minF) [minF, maxF] = [maxF, minF];
    this.inMinFreq.value = String(minF);
    this.inMaxFreq.value = String(maxF);

    this.setFMPeriodFromInput(); // read & clamp interval

    this.fmEnabled = true;
    this.log(`Random FM ON (${minF}–${maxF} Hz, ~${this.fmPeriodMs} ms step)`);
    this.fmTimer = setInterval(()=> this.fmTick(), this.fmPeriodMs);
  }

  stopFM(){
    if (!this.fmEnabled && !this.fmTimer) {
      if (this.rxChar) this.sendLine('STOP');
      this.log('Random FM OFF');
      return;
    }
    this.fmEnabled = false;
    if (this.fmTimer){ clearInterval(this.fmTimer); this.fmTimer = null; }
    if (this.rxChar) this.sendLine('STOP'); // hard stop PWM
    this.log('Random FM OFF (PWM STOP)');
  }

}

/* =================== Page controller =================== */
const devicesEl = document.getElementById('devices');
document.getElementById('btnAdd').onclick = ()=>{
  const card = new DeviceCard(devicesEl);
  (function portraitLoop(){
    card.drawPortrait();
    requestAnimationFrame(portraitLoop);
  })();
  card.connect();
};
</script>
</body>
</html>
